# jailor_dilemma
Solves jailor/chess board dilemma

Sorry I got kind of obsessed with the description. It's hard to explain this without drawings.

First, we can prove this problem is possible by comparing how many bits of information we can change
    by changing 1 out of 64 bits of information.
In other words, how much information can we convey with a single coin flip on a chess board?
Well since there are 64 different possible combinations of 6 digit boolean numbers, a maximum of 6 bits can be
    expressed with a flip of a coin.
But how do we do this? Let's using boolean/linear alebra, we can create an equation that converts 64 bits into 6 bits.
Let's jump into the problem.

Prisoner 1 and 2 are together and discuss strategy. No board or magic square has been generated yet.
They decide to create a 64x6 matrix where each row represents a unique binary number.
The first row is 0 0 0 0 0 0, the seconds row is 0 0 0 0 0 1, the third row is 0 0 0 0 1 0, etc.
They agree that the board state will be represented by a horizontal array where Heads is 1 and Tails is 0.
The first spot is the top left corner. The board is then numbered from left to right then up to down.
This meands the top left spot is #1, the top right spot is #8, and the bottom left spot is #64.
A signal will be generated by multiplying the board state by the constant 64x6 matrix.
During matrix multiplication, scalar addition will be replaced with an XOR gate.
The signal will be a 6 digit binary (zero indexing) which can be converted to 64 base ten numbers (one indexing).
When a coin is flipped, a new signal is made.
No two coin flips will produce the same signal.
Every signal can be produced with one coin flip.
Confident that the prisoners will be able to solve the riddle, Prisoner 1 enters the chess board room.

The coin that needs to be flipped is found by this:

Prisoner 1 creates a 1x64 matrix using the board which will be represented by 'x'.
Prisoner 1 multiplies x by the 64x6 matrix, which will be represented by 'A'.

So x\*A = y

'y' is the current signal the board sends which can be represented with a 6 digit binary, or 64 base ten numbers.

If the signal happens to be correct, the first coin can be flipped and the signal will not be changed.
This is because the first row of A is 0 0 0 0 0 0 so the first spot on the chess board convey's no information.

If the signal happens to be completely wrong and every digit of the 6 digit binary has to be flipped, the last coin is flipped.
This is because the last row of A is 1 1 1 1 1 1 so the last spot on the chess board changed every digit of the signal.

Using this same logic, if the current board state signals 1 0 1 1 0 1 and we want to signal 1 1 0 1 1 1 (Square #56)...
We should flip the coin on 0 1 1 0 1 0 (Square #27) because we want to change the 2nd, 3rd, and 5th digits.

This allows us to solve the problem with any board state with any magic square specified.
Try with the python script in the repository if you want proof.
